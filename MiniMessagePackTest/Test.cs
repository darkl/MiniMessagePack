using NUnit.Framework;
using System;
using MiniMessagePack;

namespace MiniMessagePackTest
{
	[TestFixture ()]
	public class Test
	{
		[Test ()]
		[TestCase(0,   new byte[] {0x00}, "min positive fixed int")]
		[TestCase(127, new byte[] {0x7f}, "max positive fixed int")]
		[TestCase(-32, new byte[] {0xe0}, "min negative fixed int")]
		[TestCase(-1,  new byte[] {0xff}, "max negative fixed int")]

		[TestCase(255, new byte[] {0xcc, 0xff}, "uint8")]
		[TestCase(-1,  new byte[] {0xd0, 0xff}, "int8")]

		[TestCase(0x0100, new byte[] {0xcd, 0x01, 0x00}, "uint16")]
		[TestCase(0x0001, new byte[] {0xcd, 0x00, 0x01}, "uint16")]
		[TestCase(0xffff, new byte[] {0xcd, 0xff, 0xff}, "uint16")]
		[TestCase(0x0100, new byte[] {0xd1, 0x01, 0x00}, "int16")]
		[TestCase(0x0001, new byte[] {0xd1, 0x00, 0x01}, "int16")]
		[TestCase(-1,     new byte[] {0xd1, 0xff, 0xff}, "int16")]

		[TestCase(0x01000000, new byte[] {0xce, 0x01, 0x00, 0x00, 0x00}, "uint32")]
		[TestCase(0x00010000, new byte[] {0xce, 0x00, 0x01, 0x00, 0x00}, "uint32")]
		[TestCase(0x00000100, new byte[] {0xce, 0x00, 0x00, 0x01, 0x00}, "uint32")]
		[TestCase(0x00000001, new byte[] {0xce, 0x00, 0x00, 0x00, 0x01}, "uint32")]
		[TestCase(0xffffffff, new byte[] {0xce, 0xff, 0xff, 0xff, 0xff}, "uint32")]
		[TestCase(0x01000000, new byte[] {0xd2, 0x01, 0x00, 0x00, 0x00}, "int32")]
		[TestCase(0x00010000, new byte[] {0xd2, 0x00, 0x01, 0x00, 0x00}, "int32")]
		[TestCase(0x00000100, new byte[] {0xd2, 0x00, 0x00, 0x01, 0x00}, "int32")]
		[TestCase(0x00000001, new byte[] {0xd2, 0x00, 0x00, 0x00, 0x01}, "int32")]
		[TestCase(-1,         new byte[] {0xd2, 0xff, 0xff, 0xff, 0xff}, "int32")]

		[TestCase(0x0100000000000000, new byte[] {0xcf, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, "uint64")]
		[TestCase(0x0001000000000000, new byte[] {0xcf, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, "uint64")]
		[TestCase(0x0000010000000000, new byte[] {0xcf, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}, "uint64")]
		[TestCase(0x0000000100000000, new byte[] {0xcf, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}, "uint64")]
		[TestCase(0x0000000001000000, new byte[] {0xcf, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00}, "uint64")]
		[TestCase(0x0000000000010000, new byte[] {0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00}, "uint64")]
		[TestCase(0x0000000000000100, new byte[] {0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00}, "uint64")]
		[TestCase(0x0000000000000001, new byte[] {0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}, "uint64")]

		// ATTENTION!!
		// msgpack spec say that it means 0xffffffffffffffff, but MiniMessagePack returns -1
		// because MiniMessagePack cannot handle uint64
		[TestCase(-1, new byte[] {0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, "uint64")]

		[TestCase(0x0100000000000000, new byte[] {0xd3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, "int64")]
		[TestCase(0x0001000000000000, new byte[] {0xd3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, "int64")]
		[TestCase(0x0000010000000000, new byte[] {0xd3, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}, "int64")]
		[TestCase(0x0000000100000000, new byte[] {0xd3, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}, "int64")]
		[TestCase(0x0000000001000000, new byte[] {0xd3, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00}, "int64")]
		[TestCase(0x0000000000010000, new byte[] {0xd3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00}, "int64")]
		[TestCase(0x0000000000000100, new byte[] {0xd3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00}, "int64")]
		[TestCase(0x0000000000000001, new byte[] {0xd3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}, "int64")]
		[TestCase(-1,                 new byte[] {0xd3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, "int64")]
		public void IntegerValue (long expected, byte[] data, string message = "")
		{
			var packer = new MiniMessagePacker ();
			var actual = packer.Unpack (data);
			Assert.AreEqual (actual.GetType (), typeof(long));
			Assert.AreEqual (expected, actual, message);
		}

		[Test()]
		[TestCase( 0.0, new byte[] { 0xca, 0x00, 0x00, 0x00, 0x00 }, "float 32")]
		[TestCase( 1.0, new byte[] { 0xca, 0x3f, 0x80, 0x00, 0x00 }, "float 32")]
		[TestCase(-2.0, new byte[] { 0xca, 0xc0, 0x00, 0x00, 0x00 }, "float 32")]
		[TestCase( 0x800000, new byte[] { 0xca, 0x4b, 0x00, 0x00, 0x00 }, "float 32")]
		[TestCase( 0x810000, new byte[] { 0xca, 0x4b, 0x01, 0x00, 0x00 }, "float 32")]
		[TestCase( 0x800100, new byte[] { 0xca, 0x4b, 0x00, 0x01, 0x00 }, "float 32")]
		[TestCase( 0x800001, new byte[] { 0xca, 0x4b, 0x00, 0x00, 0x01 }, "float 32")]
		[TestCase( 0.0, new byte[] { 0xcb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, "float 64")]
		[TestCase( 1.0, new byte[] { 0xcb, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, "float 64")]
		[TestCase( 2.0, new byte[] { 0xcb, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, "float 64")]
		[TestCase(-2.0, new byte[] { 0xcb, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, "float 64")]
		[TestCase( 0x10000000000000, new byte[] { 0xcb, 0x43, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, "float 64")]
		[TestCase( 0x10010000000000, new byte[] { 0xcb, 0x43, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }, "float 64")]
		[TestCase( 0x10000100000000, new byte[] { 0xcb, 0x43, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }, "float 64")]
		[TestCase( 0x10000001000000, new byte[] { 0xcb, 0x43, 0x30, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 }, "float 64")]
		[TestCase( 0x10000000010000, new byte[] { 0xcb, 0x43, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 }, "float 64")]
		[TestCase( 0x10000000000100, new byte[] { 0xcb, 0x43, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00 }, "float 64")]
		[TestCase( 0x10000000000001, new byte[] { 0xcb, 0x43, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }, "float 64")]
		public void FloatingValue(double expected, byte[] data, string message)
		{
			var packer = new MiniMessagePacker ();
			var actual = packer.Unpack (data);
			Assert.AreEqual (actual.GetType (), typeof(double));
			Assert.AreEqual (expected, actual, message);
		}
	}
}

